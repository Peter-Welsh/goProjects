/*
Project Euler problem number 51 (https://projecteuler.net/problem=51)

Prime digit replacements

By replacing the 1st digit of the 2-digit number *3, it turns out that six of the nine possible values: 13, 23, 43, 53, 73, and 83, are all prime.

By replacing the 3rd and 4th digits of 56**3 with the same digit, this 5-digit number is the first example having
seven primes among the ten generated numbers, yielding the family: 56003, 56113, 56333, 56443, 56663, 56773, and 56993.
Consequently 56003, being the first member of this family, is the smallest prime with this property.

Find the smallest prime which, by replacing part of the number (not necessarily adjacent digits) with the same digit, is part of an eight prime value family.

Solution By Peter Welsh
09/29/2022
*/

package main

import (
	"fmt"
	"math"
	"strconv"
	"strings"
)

func main() {
	const target = 8
	answer := getAnswer(target)
	fmt.Println(answer) // 121313
}

const substitutionChar = '1'
const substitutionDigit = 1
const substitutionStr = "1"

// Returns the smallest prime in the family of 10 numbers that has x primes, where x is the target
// "Family" is defined as a group of 10 numbers generated by replacing one or more digits with the same digit
// e.g. 56003, 56113, ... and 56993
// Returns 13 for target=6; 56003 for target=7; 121313 for target=8
func getAnswer(target int) int {
	if target <= 4 {
		return 2 // 2 is the first prime in the family: (2, 3, 5, 7)
	}
	cache := make(map[int]bool)
	var smallestPrime, score int
	for n := 1; score < target; n += 2 {
		// check only
		// a) odd numbers (no primes are even except for 2)
		// b) numbers that do not end with 1 (5/10 in their family are even)
		// c) numbers that contain a 1 (we substitute this digit with 0-9 to check the family)
		if n%10 == substitutionDigit || !strings.Contains(strconv.Itoa(n), substitutionStr) {
			continue
		}
		smallestPrime, score = getScore(n, cache)
	}
	return smallestPrime
}

// Returns the score of n and the smallest prime
// The score is the number of primes in the 10-number family
// e.g. for n=56113, the score is 7
func getScore(n int, cache map[int]bool) (int, int) {
	offset := getOffset(n) // for 56113, offset is 110
	smallestPrime := math.MaxInt32
	var candidate, score int
	// check the 10-number family
	// e.g. 56113, 56223, ... 56993, 56003
	for i := 1; i <= 10; i++ {
		multiplier := i%10 - 1 // -1 on the last iteration
		// start with 56113
		candidate = n + (offset * multiplier)
		if candidate < offset {
			// if it has leading zeroes, skip it
			continue
		}
		if isPrime(candidate, cache) {
			smallestPrime = int(math.Min(float64(smallestPrime), float64(candidate)))
			score++
		}
	}
	return smallestPrime, score
}

// Returns 110 for n=56113
// This offset can be used to cycle through the family of 10 numbers
// e.g. 56113, 56223, ... 56993, 56003
func getOffset(n int) int {
	str := strconv.Itoa(n)
	var offset int
	idxOfLastDigit := len(str) - 1
	for i := idxOfLastDigit; i >= 0; i-- {
		if str[i] == substitutionChar {
			offset += int(math.Pow10(idxOfLastDigit - i))
		}
	}
	return offset
}

func isPrime(n int, cache map[int]bool) bool {
	if isPrime, exists := cache[n]; exists {
		// check if the answer is cached
		return isPrime
	}
	if n <= 1 {
		// all primes are greater than 1
		cache[n] = false
		return false
	}
	if n%2 == 0 || n%3 == 0 {
		// 2 is a prime and 3 is a prime
		// but all other numbers evenly divisible by 2 or 3 are not prime
		cache[n] = n == 2 || n == 3
		return cache[n]
	}
	for i := 5; i <= int(math.Sqrt(float64(n))); i += 6 {
		if n%i == 0 || n%(i+2) == 0 {
			cache[n] = false
			return false
		}
	}
	cache[n] = true
	return true
}
